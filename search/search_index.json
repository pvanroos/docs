{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ceramic Docs \u00b6 Ceramic is the public dataweb. An open network for deploying and managing information. Ceramic public infrastructure serves as a secure, performant data storage backend. Version control, verifiability, Something about the linked document model, something about DIDs. Whether you're building a fully-featured application that needs to write documents to a mutable decentralized backend, hacking together a project that needs to query open information, or just want to experiment with next-generation Web3 and peer-to-peer technologies, our developer platform has the tools to support you. Quick start Installation Learn the basics \u00b6 Protocol Overview Document Model Network Design Decentralized ID Development Tools \u00b6 HTTP Client JS Client CLI Client API Reference Resources \u00b6 Discord Blog Github","title":"Ceramic Docs"},{"location":"#ceramic-docs","text":"Ceramic is the public dataweb. An open network for deploying and managing information. Ceramic public infrastructure serves as a secure, performant data storage backend. Version control, verifiability, Something about the linked document model, something about DIDs. Whether you're building a fully-featured application that needs to write documents to a mutable decentralized backend, hacking together a project that needs to query open information, or just want to experiment with next-generation Web3 and peer-to-peer technologies, our developer platform has the tools to support you. Quick start Installation","title":"Ceramic Docs"},{"location":"#learn-the-basics","text":"","title":"Learn the basics"},{"location":"#development-tools","text":"","title":"Development Tools"},{"location":"#resources","text":"","title":"Resources"},{"location":"learn/","text":"","title":"Learn"},{"location":"build/authentication/","text":"Authentication \u00b6 This guide will help you add user authentication to your project. Authentication is needed when you want to perform writes . If you only want to perform queries , you do not need authentication. Prerequisites \u00b6 Authentication requires having installed a Ceramic client in your project. Choose your setup \u00b6 DID method \u00b6 The first step in adding authentication to your project is choosing which DID method you want to support for user accounts. Due to their mutability and security, it is recommended that you use 3ID DID for users. DID Method Description Registration DID Documents Details 3ID DID A complete and flexible DID method built on Ceramic that supports key rotations and revocations Ceramic Mutable Learn Key DID A lightweight but inflexible DID method that does not support key rotations None Immutable Learn DID provider or wallet \u00b6 After deciding on a DID method, you need to install either a wallet or a provider for that method. The most commonly used DID providers and wallets can be found below. For most browser applications, it is recommended that you use 3ID Connect. Name DID Method Type Description Details 3ID Connect 3ID DID Wallet A hosted wallet and authentication system for browser apps using 3ID DIDs. Your application is not responsible for key management, and users can authenticate with their existing blockchain wallets. Learn 3id-did-provider 3ID DID Provider A JavaScript library for creating and interacting with 3ID DIDs. Your application is responsible for key management, and users need to authenticate with a DID seed or an auth secret. Learn key-did-provider-ed25519 Key DID Provider A JavaScript library for creating and interacting with Key DIDs. Your application is responsible for key managemet, and users need to authenticate with a DID seed. Learn Installation \u00b6 Install a DID wallet or provider in your project using npm. 3ID Connect $ npm install @ceramicstudio/3id-connect 3id-did-provider $ npm install 3id-did-provider key-did-provider $ npm install key-did-provider-ed25519 Authentication \u00b6 The authentication process varies depending on which wallet or provider you are using. Closely follow the steps below. 3ID Connect Import the provider import { ThreeIdConnect , < BlockchainAuthProvider > } from '@ceramicstudio/3id-connect' Example using an Ethereum wallet: import { ThreeIdConnect , EthereumAuthProvider } from '@ceramicstudio/3id-connect' Understanding BlockchainAuthProvider The BlockchainAuthProvider parameter is always required but the name shown here is just a placeholder. In your application, you should substitute in the specific BlockchainAuthProvider you are using. A full list of supported BlockchainAuthProviders can be found here . Request the user's blockchain address const addresses = await < blockchainName > . enable () Example using an Ethereum wallet: const addresses = await window . ethereum . enable () Request authentication from the user's blockchain wallet This will prompt the user with a 3ID Connect permissions window. const authProvider = new < BlockchainAuthProvider > ( < blockchainName > , addresses [ 0 ]) await threeIdConnect . connect ( authProvider ) Example using an Ethereum wallet: const authProvider = new EthereumAuthProvider ( window . ethereum , addresses [ 0 ]) await threeIdConnect . connect ( authProvider ) Create a provider instance const provider = await threeIdConnect . getDidProvider () 3id-did-provider Import the provider import ThreeIdProvider from '3id-did-provider' Get seed for DID Generate a random seed for a new user, or somehow get the existing seed for a returning user. Seeds should be a 32 byte Uint8Array. How to generate a seed Here's how to securely generate a seed in the proper format: import { randomBytes } from '@stablelib/random' const seed = randomBytes ( 32 ) Create a provider instance Option 1: Using the seed const threeId = await ThreeIdProvider . create ({ getPermission , seed }) const provider = threeId . getDidProvider () Option 2: Using an external auth method This option is useful if you want to enable multiple secrets (seeds) that are capable of controlling the 3ID DID. How to generate an authSecret Here's how to securely generate a seed in the proper format: import { randomBytes } from '@stablelib/random' const authSecret = randomBytes ( 32 ) const authId = 'myAuthenticationMethod' // a name of the auth method const threeId = await ThreeIdProvider . create ({ getPermission , authSecret , authId }) const provider = threeId . getDidProvider () Understanding getPermission The getPermission parameter is always required when creating an instance of ThreeIdProvider. It is used to give an application permission to decrypt and sign data. This function should present a dialog to the user in the wallet UI which asks for permission to access the given paths. The function is called with one parameter which is the request object. It looks like this: { type : 'authenticate' , origin : 'https://my.app.origin' , payload : { paths : [ '/path/1' , '/path/2' ] } } In the above example the app with origin https://my.app.origin is requesting access to /path/1 and /path/2. If the user approves, the function should return the paths array. If they decline, it will return an empty array. Note that a user may approve only some of the requested paths, which would return an array containing only the approved paths. The most simple getPermission function simply grants all requested permissions. const getPermission = async ( request ) => { return request . payload . paths } key-did-provider Import the provider Import the Key DID provider into your project. import { Ed25519Provider } from 'key-did-provider-ed25519' Get seed for DID Generate a random seed for a new user, or somehow get the existing seed for a returning user. Seeds should be a 32 byte Uint8Array. How to generate a seed Here's how to securely generate a seed in the proper format: import { randomBytes } from '@stablelib/random' const seed = randomBytes ( 32 ) Create a provider instance using the seed const provider = new Ed25519Provider ( seed ) Set the provider \u00b6 Set the authenticated provider instance to your Ceramic client in order to perform writes. await ceramic . setDIDProvider ( provider ) Usage \u00b6 After authenticating, the user will now be able to perform writes on Ceramic using their DID.","title":"Authentication"},{"location":"build/authentication/#authentication","text":"This guide will help you add user authentication to your project. Authentication is needed when you want to perform writes . If you only want to perform queries , you do not need authentication.","title":"Authentication"},{"location":"build/authentication/#prerequisites","text":"Authentication requires having installed a Ceramic client in your project.","title":"Prerequisites"},{"location":"build/authentication/#choose-your-setup","text":"","title":"Choose your setup"},{"location":"build/authentication/#did-method","text":"The first step in adding authentication to your project is choosing which DID method you want to support for user accounts. Due to their mutability and security, it is recommended that you use 3ID DID for users. DID Method Description Registration DID Documents Details 3ID DID A complete and flexible DID method built on Ceramic that supports key rotations and revocations Ceramic Mutable Learn Key DID A lightweight but inflexible DID method that does not support key rotations None Immutable Learn","title":"DID method"},{"location":"build/authentication/#did-provider-or-wallet","text":"After deciding on a DID method, you need to install either a wallet or a provider for that method. The most commonly used DID providers and wallets can be found below. For most browser applications, it is recommended that you use 3ID Connect. Name DID Method Type Description Details 3ID Connect 3ID DID Wallet A hosted wallet and authentication system for browser apps using 3ID DIDs. Your application is not responsible for key management, and users can authenticate with their existing blockchain wallets. Learn 3id-did-provider 3ID DID Provider A JavaScript library for creating and interacting with 3ID DIDs. Your application is responsible for key management, and users need to authenticate with a DID seed or an auth secret. Learn key-did-provider-ed25519 Key DID Provider A JavaScript library for creating and interacting with Key DIDs. Your application is responsible for key managemet, and users need to authenticate with a DID seed. Learn","title":"DID provider or wallet"},{"location":"build/authentication/#installation","text":"Install a DID wallet or provider in your project using npm. 3ID Connect $ npm install @ceramicstudio/3id-connect 3id-did-provider $ npm install 3id-did-provider key-did-provider $ npm install key-did-provider-ed25519","title":"Installation"},{"location":"build/authentication/#authentication_1","text":"The authentication process varies depending on which wallet or provider you are using. Closely follow the steps below. 3ID Connect","title":"Authentication"},{"location":"build/authentication/#set-the-provider","text":"Set the authenticated provider instance to your Ceramic client in order to perform writes. await ceramic . setDIDProvider ( provider )","title":"Set the provider"},{"location":"build/authentication/#usage","text":"After authenticating, the user will now be able to perform writes on Ceramic using their DID.","title":"Usage"},{"location":"build/installation/","text":"Installation \u00b6 Install a Ceramic client to perform writes and queries on the network. Project status: Clay testnet is now live. Clay is a decentralized public network ready for experimental application development and testing, but you still may encounter a few issues. It is the last major milestone before Fire mainnet, which is under development and will launch in late Q1 2021. Documents published on Clay will not be portable to Fire. Please reach out on Discord or create an issue on Githb to report any issues. Clients \u00b6 Ceramic is available in a variety of clients suited for different use cases. For optimal performance, it is recommended that you use the HTTP Client when building an application. Client Description Usage Details HTTP An API for interacting with a remote Ceramic daemon over HTTP Runtime Learn Core An API for running the entire Ceramic protocol in a local JavaScript environment, such as directly in-browser Runtime Learn CLI A command line interface for interacting with a Ceramic node Development Learn Installation \u00b6 Open your terminal and install a client using npm. HTTP $ npm install @ceramicnetwork/http-client Core $ npm install @ceramicnetwork/core CLI $ npm install -g @ceramicnetwork/cli The CLI requires Node.js. Make sure to have an up-to-date version installed on your machine. Setup \u00b6 Setup your client within your project. HTTP Import the HTTP client import CeramicClient from '@ceramicnetwork/http-client' Connect to a node const API_URL = \"http://yourceramicnode.com\" Node options When using the HTTP API, you need to connect to a remote Ceramic node by passing its URL. Here are your options for nodes that run on the Clay testnet. Choose the option that best suits your use case: Community gateway https://gateway-clay.ceramic.network : Provides read-only access to the Clay testnet. (recommended) Community dev node https://ceramic-clay.3boxlabs.com : Provides write and read access to the Clay testnet. This node is occasionally wiped and does not guarantee document persistence. (recommended) Run your own node https://yourEndpoint.com : Provides write and read access to the Clay testnet. Running your own node allows you to persist documents and have full control, however this is process is not yet well documented. If you choose to run your own node, be sure to add your node to the peerlist by submitting a pull request. This allows other nodes to discover your node. LocalHost https://localhost:7007 : Provides read access to the Clay testnet. Writes made to this local node will only be available to nodes in the peerlist , but will not be available to other nodes on the network. Users need to first have a Ceramic daemon running locally using the CLI. Create an instance const ceramic = new CeramicClient ( API_URL ) Core Import the Core client import Ceramic from '@ceramicnetwork/core' Import IPFS with dag-jose Ceramic utilizes the dag-jose IPLD codec to store signed and encrypted data in IPFS. In order to create an instance of Ceramic core, you first need to create an instance of js-ipfs with dag-jose enabled. import IPFS from 'ipfs' import dagJose from 'dag-jose' import basicsImport from 'multiformats/cjs/src/basics-import.js' import legacy from 'multiformats/cjs/src/legacy.js' basicsImport . multicodec . add ( dagJose ) const format = legacy ( basicsImport , dagJose . name ) Create an IPFS instance const ipfs = Ipfs . create ({ ipld : { formats : [ format ] }, }) Create a Ceramic instance Create an instance of Ceramic by passing ipfs and an optional configuration object. const ceramic = await Ceramic . create ( ipfs , config ) CLI Start the Ceramic daemon This commands starts a local Ceramic node. $ ceramic daemon Connect to a remote Ceramic node By default the Ceramic CLI communicates with the local node that you started with the ceramic daemon command. However, it is possible to use the CLI to communicate with a remote node. To do this, use the config set command to set the ceramicHost variable to the URL of the node you wish to use. $ ceramic config set ceramicHost 'https://yourceramicnode.com' Node options When using the CLI, you need to connect to a remote Ceramic node by passing its URL. Here are your options for nodes that run on the Clay testnet. Choose the option that best suits your use case: LocalHost https://localhost:7007 : Enabled by default in the CLI. Provides read access to the Clay testnet. Writes made to this local node will only be available to nodes in the peerlist , but will not be available to other nodes on the network. Community gateway https://gateway-clay.ceramic.network : Provides read-only access to the Clay testnet. Community dev node https://ceramic-clay.3boxlabs.com : Provides write and read access to the Clay testnet. This node is occasionally wiped and does not guarantee document persistence. (recommended) Run your own node https://yourEndpoint.com : Provides write and read access to the Clay testnet. Running your own node allows you to persist documents and have full control, however this is process is not yet well documented. If you choose to run your own node, be sure to add your node to the peerlist by submitting a pull request. This allows other nodes to discover your node.","title":"Installation"},{"location":"build/installation/#installation","text":"Install a Ceramic client to perform writes and queries on the network. Project status: Clay testnet is now live. Clay is a decentralized public network ready for experimental application development and testing, but you still may encounter a few issues. It is the last major milestone before Fire mainnet, which is under development and will launch in late Q1 2021. Documents published on Clay will not be portable to Fire. Please reach out on Discord or create an issue on Githb to report any issues.","title":"Installation"},{"location":"build/installation/#clients","text":"Ceramic is available in a variety of clients suited for different use cases. For optimal performance, it is recommended that you use the HTTP Client when building an application. Client Description Usage Details HTTP An API for interacting with a remote Ceramic daemon over HTTP Runtime Learn Core An API for running the entire Ceramic protocol in a local JavaScript environment, such as directly in-browser Runtime Learn CLI A command line interface for interacting with a Ceramic node Development Learn","title":"Clients"},{"location":"build/installation/#installation_1","text":"Open your terminal and install a client using npm. HTTP $ npm install @ceramicnetwork/http-client Core $ npm install @ceramicnetwork/core CLI $ npm install -g @ceramicnetwork/cli The CLI requires Node.js. Make sure to have an up-to-date version installed on your machine.","title":"Installation"},{"location":"build/installation/#setup","text":"Setup your client within your project. HTTP","title":"Setup"},{"location":"build/pinning/","text":"Pinning \u00b6 Pinning allows you to add and remove documents from the permanent pinset in your Ceramic node. By default Ceramic will garbage collect any document that has been created, modified, or loaded after some period of time. In order to prevent the loss of documents due to garbage collection, you need to pin the documents that you wish to persist. Pinning instructs the Ceramic node to keep them around until they are unpinned. Prerequisites \u00b6 Pinning requires having installed a Ceramic client in your project. Add to pinset \u00b6 Use the pin.add() method to add a document to your permanent pinset. const docid = 'kjzl6cwe1jw14...' await ceramic . pin . add ( docid ) API reference Remove from pinset \u00b6 Use the pin.rm() method to remove a document from your permanent pinset. const docid = 'kjzl6cwe1jw14...' await ceramic . pin . rm ( docid ) API reference List documents in pinset \u00b6 Use the pin.ls() method to list documents currently in your permanent pinset. const docIds = await ceramic . pin . ls () API reference","title":"Pinning"},{"location":"build/pinning/#pinning","text":"Pinning allows you to add and remove documents from the permanent pinset in your Ceramic node. By default Ceramic will garbage collect any document that has been created, modified, or loaded after some period of time. In order to prevent the loss of documents due to garbage collection, you need to pin the documents that you wish to persist. Pinning instructs the Ceramic node to keep them around until they are unpinned.","title":"Pinning"},{"location":"build/pinning/#prerequisites","text":"Pinning requires having installed a Ceramic client in your project.","title":"Prerequisites"},{"location":"build/pinning/#add-to-pinset","text":"Use the pin.add() method to add a document to your permanent pinset. const docid = 'kjzl6cwe1jw14...' await ceramic . pin . add ( docid ) API reference","title":"Add to pinset"},{"location":"build/pinning/#remove-from-pinset","text":"Use the pin.rm() method to remove a document from your permanent pinset. const docid = 'kjzl6cwe1jw14...' await ceramic . pin . rm ( docid ) API reference","title":"Remove from pinset"},{"location":"build/pinning/#list-documents-in-pinset","text":"Use the pin.ls() method to list documents currently in your permanent pinset. const docIds = await ceramic . pin . ls () API reference","title":"List documents in pinset"},{"location":"build/queries/","text":"Queries \u00b6 This guide demonstrates how to query documents on the Ceramic network during runtime using the HTTP and core clients. You can also use the CLI to query documents as shown in the Quick Start guide. Prerequisites \u00b6 You need to have an installed client to perform queries during runtime. Query a document \u00b6 Use the loadDocument() method to load a single document using its DocID . const docid = 'kjzl6cwe1jw14...' const doc = await ceramic . loadDocument ( docid ) API reference Query a deterministic document \u00b6 One the writes page, we discussed how to create a document with the deterministic parameter set to true. Since this parameter allows us to generate the exact same DocID if we create two documents with the same doctype and DocParams , it is possible to \"query\" the document using the same createDocument() method that we used to initially create it without needing to know the DocID before performing the query. Note we are setting the DocOpts parameters ( anchor and publish ) to false so that we are only loading the document and not publishing any changes to the network. const doc = ceramic . createDocument ( 'tile' , { deterministic : true , metadata : { controllers : [ 'did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H' ], family : 'example family' }, { anchor : false , publish : false } }) API reference Query multiple documents \u00b6 Use the multiQuery() method to load multiple documents at once. The returned object docMap is a map from DocIDs to document instances. const queries = [{ docId : 'kjzl6cwe1jw...14' }, { docId : 'kjzl6cwe1jw...15' }] const docMap = await ceramic . multiQuery ( queries ) API reference Query document paths \u00b6 Use the multiQuery() method to load one or more documents using known paths from a root document to its linked documents. Imagine a document kjzl6cwe1jw...14 whose content contains the DocIDs of two other documents. These DocIDs exist at various levels within a nested JSON structure. { a : 'kjzl6cwe1jw...15' , b : { c : 'kjzl6cwe1jw...16' } } In the document above, the path from root document kjzl6cwe1jw...14 to linked document kjzl6cwe1jw...15 is /a and the path to linked document kjzl6cwe1jw...16 is /b/c . Using the DocID of the root document and the paths outlined here, we use multiQuery() to query all three documents at once without needing to explicitly know the DocIDs of the two linked documents. The multiQuery() below will return a map with all three documents. const queries = [{ docId : 'kjzl6cwe1jw...14' paths : [ '/a' , '/b/c' ] }] const docMap = await ceramic . multiQuery ( queries ) API reference","title":"Queries"},{"location":"build/queries/#queries","text":"This guide demonstrates how to query documents on the Ceramic network during runtime using the HTTP and core clients. You can also use the CLI to query documents as shown in the Quick Start guide.","title":"Queries"},{"location":"build/queries/#prerequisites","text":"You need to have an installed client to perform queries during runtime.","title":"Prerequisites"},{"location":"build/queries/#query-a-document","text":"Use the loadDocument() method to load a single document using its DocID . const docid = 'kjzl6cwe1jw14...' const doc = await ceramic . loadDocument ( docid ) API reference","title":"Query a document"},{"location":"build/queries/#query-a-deterministic-document","text":"One the writes page, we discussed how to create a document with the deterministic parameter set to true. Since this parameter allows us to generate the exact same DocID if we create two documents with the same doctype and DocParams , it is possible to \"query\" the document using the same createDocument() method that we used to initially create it without needing to know the DocID before performing the query. Note we are setting the DocOpts parameters ( anchor and publish ) to false so that we are only loading the document and not publishing any changes to the network. const doc = ceramic . createDocument ( 'tile' , { deterministic : true , metadata : { controllers : [ 'did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H' ], family : 'example family' }, { anchor : false , publish : false } }) API reference","title":"Query a deterministic document"},{"location":"build/queries/#query-multiple-documents","text":"Use the multiQuery() method to load multiple documents at once. The returned object docMap is a map from DocIDs to document instances. const queries = [{ docId : 'kjzl6cwe1jw...14' }, { docId : 'kjzl6cwe1jw...15' }] const docMap = await ceramic . multiQuery ( queries ) API reference","title":"Query multiple documents"},{"location":"build/queries/#query-document-paths","text":"Use the multiQuery() method to load one or more documents using known paths from a root document to its linked documents. Imagine a document kjzl6cwe1jw...14 whose content contains the DocIDs of two other documents. These DocIDs exist at various levels within a nested JSON structure. { a : 'kjzl6cwe1jw...15' , b : { c : 'kjzl6cwe1jw...16' } } In the document above, the path from root document kjzl6cwe1jw...14 to linked document kjzl6cwe1jw...15 is /a and the path to linked document kjzl6cwe1jw...16 is /b/c . Using the DocID of the root document and the paths outlined here, we use multiQuery() to query all three documents at once without needing to explicitly know the DocIDs of the two linked documents. The multiQuery() below will return a map with all three documents. const queries = [{ docId : 'kjzl6cwe1jw...14' paths : [ '/a' , '/b/c' ] }] const docMap = await ceramic . multiQuery ( queries ) API reference","title":"Query document paths"},{"location":"build/quick-start/","text":"Project status: Clay testnet is now live. Clay is a decentralized public network ready for experimental application development and testing, but you still may encounter a few issues. It is the last major milestone before Fire mainnet, which is under development and will launch in late Q1 2021. Documents published on Clay will not be portable to Fire. Please reach out on Discord or create an issue on Githb to report any issues. Quick start \u00b6 Learn the basics by setting up and interacting with the Ceramic CLI. This tutorial serves as a simple introduction to Ceramic concepts. See installation to fully configure your client and start building applications. Prerequisites \u00b6 This quick start guide will use a terminal, Node.js , and npm . Make sure to have these installed on your machine. Install the CLI \u00b6 Install the Ceramic CLI using your terminal. npm install -g @ceramicnetwork/cli Start the daemon \u00b6 Start a Ceramic daemon on your local machine and automatically connect to it on port 7007, http://localhost:7007 . ceramic daemon Node configurations There are multiple options you can configure when you start the ceramic daemon. Network : By default the CLI starts a Ceramic node on the clay testnet. If you would like to use a different Ceramic network, you can specify this with the --network option. Additional configurations : Use the ceramic daemon -h command to see additional options. Authentication \u00b6 By default, the Ceramic CLI is authenticated with a Key DID . The seed for this DID is stored in ~/.ceramic/config.json . If this file is not present on startup a new DID will be randomly generated. It's currently not possible to use the Ceramic CLI with other DID methods. Create a document \u00b6 Use the create command to create a new document. In the example below we create a document using the tile doctype. Command $ ceramic create tile --content '{ \"Foo\": \"Bar\" }' Output DocID ( kjzl6cwe1jw14a80400xpbj97sutzdssg9rklbyykj0zdxzbpmww4x9e9w4vcyr ) { \"Foo\" : \"Bar\" } The first line of the output is the DocID , which is the persistent identifier of our newly created document. This DocID will be different for you, since you created it with your DID. Below the DocID is the current content of the document. More options --controllers : set the controller of the document --schema : set the schema of the document Run ceramic create -h to see all available options Query a document \u00b6 Use the show command to query the current state of a document. You will need to provide its DocID . Command $ ceramic show kjzl6cwe1jw14a80400xpbj97sutzdssg9rklbyykj0zdxzbpmww4x9e9w4vcyr You should use your DocID instead of the DocID included here. Output { \"Foo\" : \"Bar\" } Use the state command to query the entire state of a document. Command $ ceramic state kjzl6cwe1jw14a80400xpbj97sutzdssg9rklbyykj0zdxzbpmww4x9e9w4vcyr You should use your DocID instead of the DocID included here. Output { \"doctype\" : \"tile\" , \"content\" : { \"Foo\" : \"Bar\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqceray2cbrwx45oa5nesee4s4cggkodmsttzuqfzh32yat3o26iw5m5rq\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/11/2021, 11:45:00 AM\" } Here we can see various information about the document such as content , controllers , and schema . In your output you should see your DID as the controller, instead of the DID we show here. We can also see the current anchorStatus of our document, and that it has been scheduled to be anchored at 11:45 on the 11 th of January 2021. Once this anchor is finalized, the state of the document will automatically be updated with a new entry in the log and anchorStatus will be set to ANCHORED . Update a document \u00b6 Use the change command to update a document. Your DID must be the controller of the document in order to update it. Command $ ceramic change kjzl6cwe1jw145dqtpe73w2sfbn6gz8d0fdvn0etrnflpdyqryltfyem4u1vkok --content '{ \"title\": \"My updated document\" }' You should use your DocID instead of the DocID included here. Output { \"title\" : \"My updated document\" } More options Currently you can change content , controllers , and schema using the CLI. Run ceramic change -h for more information. Create a schema \u00b6 In Ceramic you can enforce that documents adhere to a specified schema. The schemas themselves are Ceramic documents where the content is a json-schema . For example we can create a schema that requires a document to have a title and message . Command $ ceramic create tile --content ' { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Reward\", \"type\": \"object\", \"properties\": { \"title\": { \"type\": \"string\" }, \"message\": { \"type\": \"string\" } }, \"required\": [ \"message\", \"title\" ] }' Output DocID ( kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb ) { \"type\" : \"object\" , \"title\" : \"Reward\" , \" $schema \" : \"http://json-schema.org/draft-07/schema#\" , \"required\" : [ \"message\" , \"title\" ] , \"properties\" : { \"title\" : { \"type\" : \"string\" } , \"message\" : { \"type\" : \"string\" } } } Create a document that uses a schema \u00b6 First, use the commits command to list the commitIDs contained in the schema document. When creating a document that uses this schema, we need to use a commitID instead of the DocID to enforce that we are using a specific version of the schema since the schema document is mutable and can be updated. Command $ ceramic commits kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb You should use your DocID instead of the DocID included here. Output [ \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" ] If a document contains multiple commits and you're not sure which one you want, use the show command to show the content of the document at the given commit. Once you retrieve the desired commit, you can now create a document that is enforced to conform to this version of the schema. Use the create command and pass the --schema option along with your commitID. Command $ ceramic ceramic create tile --content '{ \"title\": \"My first document with schema\", \"message\": \"Hello World\" }' --schema k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8 You should use your commitID instead of the commitID included here. Output DocID ( kjzl6cwe1jw149tvfh6otqfzd2hfknkifb1z2lakozkicvau0xldzzdzwfbsztj ) { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" } Query the document you created \u00b6 Use the state command to query the state of the document we just created. We can see that the schema is set to the correct commitID. Command $ ceramic state kjzl6cwe1jw14b5sr79heovz7fziz4dxcn8upx3bcesriloqcui137k6rq6g2mn You should use your DocID instead of the DocID included here. Output { \"doctype\" : \"tile\" , \"content\" : { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" } , \"metadata\" : { \"schema\" : \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" , \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera5qxg5zabjjvwpcbia6c3t6vebgo4brgmsagxezdjgk4vxnzwb5hq\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/13/2021, 1:45:00 PM\" } That's it! \u00b6 Congratulations on completing this tutorial! You're well on your way to becoming a Ceramic developer. Now let's install Ceramic in your project \u2192","title":"Quick Start"},{"location":"build/quick-start/#quick-start","text":"Learn the basics by setting up and interacting with the Ceramic CLI. This tutorial serves as a simple introduction to Ceramic concepts. See installation to fully configure your client and start building applications.","title":"Quick start"},{"location":"build/quick-start/#prerequisites","text":"This quick start guide will use a terminal, Node.js , and npm . Make sure to have these installed on your machine.","title":"Prerequisites"},{"location":"build/quick-start/#install-the-cli","text":"Install the Ceramic CLI using your terminal. npm install -g @ceramicnetwork/cli","title":"Install the CLI"},{"location":"build/quick-start/#start-the-daemon","text":"Start a Ceramic daemon on your local machine and automatically connect to it on port 7007, http://localhost:7007 . ceramic daemon Node configurations There are multiple options you can configure when you start the ceramic daemon. Network : By default the CLI starts a Ceramic node on the clay testnet. If you would like to use a different Ceramic network, you can specify this with the --network option. Additional configurations : Use the ceramic daemon -h command to see additional options.","title":"Start the daemon"},{"location":"build/quick-start/#authentication","text":"By default, the Ceramic CLI is authenticated with a Key DID . The seed for this DID is stored in ~/.ceramic/config.json . If this file is not present on startup a new DID will be randomly generated. It's currently not possible to use the Ceramic CLI with other DID methods.","title":"Authentication"},{"location":"build/quick-start/#create-a-document","text":"Use the create command to create a new document. In the example below we create a document using the tile doctype. Command $ ceramic create tile --content '{ \"Foo\": \"Bar\" }' Output DocID ( kjzl6cwe1jw14a80400xpbj97sutzdssg9rklbyykj0zdxzbpmww4x9e9w4vcyr ) { \"Foo\" : \"Bar\" } The first line of the output is the DocID , which is the persistent identifier of our newly created document. This DocID will be different for you, since you created it with your DID. Below the DocID is the current content of the document. More options --controllers : set the controller of the document --schema : set the schema of the document Run ceramic create -h to see all available options","title":"Create a document"},{"location":"build/quick-start/#query-a-document","text":"Use the show command to query the current state of a document. You will need to provide its DocID . Command $ ceramic show kjzl6cwe1jw14a80400xpbj97sutzdssg9rklbyykj0zdxzbpmww4x9e9w4vcyr You should use your DocID instead of the DocID included here. Output { \"Foo\" : \"Bar\" } Use the state command to query the entire state of a document. Command $ ceramic state kjzl6cwe1jw14a80400xpbj97sutzdssg9rklbyykj0zdxzbpmww4x9e9w4vcyr You should use your DocID instead of the DocID included here. Output { \"doctype\" : \"tile\" , \"content\" : { \"Foo\" : \"Bar\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqceray2cbrwx45oa5nesee4s4cggkodmsttzuqfzh32yat3o26iw5m5rq\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/11/2021, 11:45:00 AM\" } Here we can see various information about the document such as content , controllers , and schema . In your output you should see your DID as the controller, instead of the DID we show here. We can also see the current anchorStatus of our document, and that it has been scheduled to be anchored at 11:45 on the 11 th of January 2021. Once this anchor is finalized, the state of the document will automatically be updated with a new entry in the log and anchorStatus will be set to ANCHORED .","title":"Query a document"},{"location":"build/quick-start/#update-a-document","text":"Use the change command to update a document. Your DID must be the controller of the document in order to update it. Command $ ceramic change kjzl6cwe1jw145dqtpe73w2sfbn6gz8d0fdvn0etrnflpdyqryltfyem4u1vkok --content '{ \"title\": \"My updated document\" }' You should use your DocID instead of the DocID included here. Output { \"title\" : \"My updated document\" } More options Currently you can change content , controllers , and schema using the CLI. Run ceramic change -h for more information.","title":"Update a document"},{"location":"build/quick-start/#create-a-schema","text":"In Ceramic you can enforce that documents adhere to a specified schema. The schemas themselves are Ceramic documents where the content is a json-schema . For example we can create a schema that requires a document to have a title and message . Command $ ceramic create tile --content ' { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Reward\", \"type\": \"object\", \"properties\": { \"title\": { \"type\": \"string\" }, \"message\": { \"type\": \"string\" } }, \"required\": [ \"message\", \"title\" ] }' Output DocID ( kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb ) { \"type\" : \"object\" , \"title\" : \"Reward\" , \" $schema \" : \"http://json-schema.org/draft-07/schema#\" , \"required\" : [ \"message\" , \"title\" ] , \"properties\" : { \"title\" : { \"type\" : \"string\" } , \"message\" : { \"type\" : \"string\" } } }","title":"Create a schema"},{"location":"build/quick-start/#create-a-document-that-uses-a-schema","text":"First, use the commits command to list the commitIDs contained in the schema document. When creating a document that uses this schema, we need to use a commitID instead of the DocID to enforce that we are using a specific version of the schema since the schema document is mutable and can be updated. Command $ ceramic commits kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb You should use your DocID instead of the DocID included here. Output [ \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" ] If a document contains multiple commits and you're not sure which one you want, use the show command to show the content of the document at the given commit. Once you retrieve the desired commit, you can now create a document that is enforced to conform to this version of the schema. Use the create command and pass the --schema option along with your commitID. Command $ ceramic ceramic create tile --content '{ \"title\": \"My first document with schema\", \"message\": \"Hello World\" }' --schema k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8 You should use your commitID instead of the commitID included here. Output DocID ( kjzl6cwe1jw149tvfh6otqfzd2hfknkifb1z2lakozkicvau0xldzzdzwfbsztj ) { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" }","title":"Create a document that uses a schema"},{"location":"build/quick-start/#query-the-document-you-created","text":"Use the state command to query the state of the document we just created. We can see that the schema is set to the correct commitID. Command $ ceramic state kjzl6cwe1jw14b5sr79heovz7fziz4dxcn8upx3bcesriloqcui137k6rq6g2mn You should use your DocID instead of the DocID included here. Output { \"doctype\" : \"tile\" , \"content\" : { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" } , \"metadata\" : { \"schema\" : \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" , \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera5qxg5zabjjvwpcbia6c3t6vebgo4brgmsagxezdjgk4vxnzwb5hq\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/13/2021, 1:45:00 PM\" }","title":"Query the document you created"},{"location":"build/quick-start/#thats-it","text":"Congratulations on completing this tutorial! You're well on your way to becoming a Ceramic developer. Now let's install Ceramic in your project \u2192","title":"That's it!"},{"location":"build/share/","text":"Share your project \u00b6 Congratulations on making it this far! We're excited to see what you've built with Ceramic. To help the community discover your work: Add the ceramic topic to your project on Github Add your project to the Awesome Ceramic page on Github","title":"Share your work"},{"location":"build/share/#share-your-project","text":"Congratulations on making it this far! We're excited to see what you've built with Ceramic. To help the community discover your work: Add the ceramic topic to your project on Github Add your project to the Awesome Ceramic page on Github","title":"Share your project"},{"location":"build/troubleshooting/","text":"Troubleshooting \u00b6 Developer Chat \u00b6 For developer questions, chat, and support, join us on the Ceramic Discord . Github Issues \u00b6 For specific bugs, issues, and feature requests, create a Github issue on the appropriate repository. Before creating a new issue, please search existing issues to ensure your issue has not already been reported. If it has, just add a new comment to that issue explaining that you are encourering the same problem. Twitter \u00b6 For updates and news from the Ceramic ecosystem, follow Ceramic on Twitter .","title":"Troubleshooting"},{"location":"build/troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"build/troubleshooting/#developer-chat","text":"For developer questions, chat, and support, join us on the Ceramic Discord .","title":"Developer Chat"},{"location":"build/troubleshooting/#github-issues","text":"For specific bugs, issues, and feature requests, create a Github issue on the appropriate repository. Before creating a new issue, please search existing issues to ensure your issue has not already been reported. If it has, just add a new comment to that issue explaining that you are encourering the same problem.","title":"Github Issues"},{"location":"build/troubleshooting/#twitter","text":"For updates and news from the Ceramic ecosystem, follow Ceramic on Twitter .","title":"Twitter"},{"location":"build/writes/","text":"Writes \u00b6 Writes are interactions that write to Ceramic, such as creating new documents or modifying existing documents. This guide demonstrates how to make writes during runtime using the HTTP and core clients. To make writes using the CLI, see Quick Start . Prerequisites \u00b6 You need an installed client and an authenticated user to perform writes to the network during runtime. Create a document \u00b6 Use the createDocument() method to create a new document. const doc = await ceramic . createDocument ( doctype , docParams , docOpts ) Example In this example we create a document where we set doctype , content , schema , controllers , and family . const doc = await ceramic . createDocument ( 'tile' , { content : { foo : \"bar\" } metadata : { schema : \"ceramic://kyz123...456\" , controllers : [ \"did:3:kyz123...456\" ], family : \"doc family\" } }) API reference Parameters \u00b6 When creating a document, the first parameter is the doctype and it is always required. Other parameters including content will vary depending on the doctype specification. If you do not specify a doctype or if your parameters do not meet the doctype's requirements, your transaction will fail. Doctype Doctypes are rules that govern the behavior of documents on the Ceramic network. A doctype is required. Parameter Required? Value Description doctype required string Specifies rules for content , metadata , and conflict resolution Supported doctypes Ceramic currently supports two doctypes: tile for storing arbitrary JSON content and caip-10 link for storing a proof that binds a DID to a blockchain account. Read each doctype's documentation for more information on its parameters below. DocParams DocParams are specifics related to your document including content , metadata , and deterministic . All of these properties are optional. Content Parameter Required? Value Description Notes content optional object The content of your document Must conform to the doctype and schema if present When content is included during document creation, the document's genesis commit will be signed by the authenticated user's DID. When content is omitted, then the genesis commit will not be signed. Metadata Parameter Required? Value Description Notes schema optional string URL of a Ceramic document that contains a JSON schema If set, schema will be enforced on content controllers optional array of strings Defines the DID that is allowed to modify the document If empty, defaults to currently authenticated DID family optional string Allows you to group similar documents into families Useful for indexing groups of like documents on the network API reference Deterministic Parameter Required? Value Description Notes deterministic optional boolean If false, allows documents with the same doctype , content , and metadata to generate unique DocIDs If empty, defaults to false Using the deterministic parameter For most use cases you will likely want to leave the deterministic parameter set to false. However for special circumstances, you may want this to be set to true. For example this should be set to true if you would like to enable deterministic queries for your document. If this is your use case, then it is also important that you omit all content during document creation. You can proceed to add content to your document by updating it . API reference DocOpts (optional) DocOpts are options that can be passed to each operation on a document (create, change, load) that control network behaviors performed as part of the operation. They are not included in the document itself. Parameter Required? Value Description Default value anchor optional boolean Request an anchor after the update was made true publish optional boolean Publish the update to the network true sync optional boolean Sync document updates from the network true API reference Update a document \u00b6 Use the doc.change() method to update the content or metadata of your document. Any update to a document must conform to the update rules specified by the document's doctype . Note that you can also pass DocOpts parameters to this method if you wish to not use the default behavior of publishing and/or anchoring your change, but this behavior should be reserved for advanced use cases. await doc . change ({ content : { foo : \"updated\" }}) API reference Document information \u00b6 To get specific information about the document that you created or loaded you can use the accessors on the Doctype class. Below are some examples. API reference DocID \u00b6 Use the doc.id property to get the unique DocID for this document. const docId = doc . id API reference Latest CommitID \u00b6 Use the doc.commitId property to get latest CommitID of a document. const commitId = doc . commitId API reference Anchor CommitIDs \u00b6 Use the doc.anchorCommitIds property to get all CommitIDs which are anchor commits for this document. const anchorCommits = doc . anchorCommitIds API reference","title":"Writes"},{"location":"build/writes/#writes","text":"Writes are interactions that write to Ceramic, such as creating new documents or modifying existing documents. This guide demonstrates how to make writes during runtime using the HTTP and core clients. To make writes using the CLI, see Quick Start .","title":"Writes"},{"location":"build/writes/#prerequisites","text":"You need an installed client and an authenticated user to perform writes to the network during runtime.","title":"Prerequisites"},{"location":"build/writes/#create-a-document","text":"Use the createDocument() method to create a new document. const doc = await ceramic . createDocument ( doctype , docParams , docOpts ) Example In this example we create a document where we set doctype , content , schema , controllers , and family . const doc = await ceramic . createDocument ( 'tile' , { content : { foo : \"bar\" } metadata : { schema : \"ceramic://kyz123...456\" , controllers : [ \"did:3:kyz123...456\" ], family : \"doc family\" } }) API reference","title":"Create a document"},{"location":"build/writes/#parameters","text":"When creating a document, the first parameter is the doctype and it is always required. Other parameters including content will vary depending on the doctype specification. If you do not specify a doctype or if your parameters do not meet the doctype's requirements, your transaction will fail.","title":"Parameters"},{"location":"build/writes/#update-a-document","text":"Use the doc.change() method to update the content or metadata of your document. Any update to a document must conform to the update rules specified by the document's doctype . Note that you can also pass DocOpts parameters to this method if you wish to not use the default behavior of publishing and/or anchoring your change, but this behavior should be reserved for advanced use cases. await doc . change ({ content : { foo : \"updated\" }}) API reference","title":"Update a document"},{"location":"build/writes/#document-information","text":"To get specific information about the document that you created or loaded you can use the accessors on the Doctype class. Below are some examples. API reference","title":"Document information"},{"location":"build/writes/#docid","text":"Use the doc.id property to get the unique DocID for this document. const docId = doc . id API reference","title":"DocID"},{"location":"build/writes/#latest-commitid","text":"Use the doc.commitId property to get latest CommitID of a document. const commitId = doc . commitId API reference","title":"Latest CommitID"},{"location":"build/writes/#anchor-commitids","text":"Use the doc.anchorCommitIds property to get all CommitIDs which are anchor commits for this document. const anchorCommits = doc . anchorCommitIds API reference","title":"Anchor CommitIDs"},{"location":"learn/overview/","text":"Ceramic overview \u00b6 Welcome to Ceramic developer documentation. Whether you want to install Ceramic in your project, run a node or just learn the basics , this site has the tools and resources for you. First, let's explore the high-level features, capabilities, and design of Ceramic. Document-based data model \u00b6 On Ceramic, every piece of content is modeled as a mutable document . These documents can represent almost any type of information and behave similar to your favorite NoSQL database. DID-based user model \u00b6 Ceramic relies on DIDs for user accounts. DIDs are used to authenticate transactions on documents and give users true control of their data. Verifiable information \u00b6 Authenticated, schema-enforced, consensus over state, strong security. conflict resolution. Worldwide/Public dataweb \u00b6 These documents can reference other documents to form a decentralized graph of linked information that lives beyond any silo. Beyond silos. Worldwide graph of information Decentralized network \u00b6 Collection of nodes all over the world that communicate over a peer-to-peer network. Is not reliant on a single server, nodes are not reliant on a supercomputer to run, designed for efficiency and scale to support all environments incl. resource constrained environments, this helps keep the network decentralized and resistant to the centralizing effects of resource demanding infrastructure. All aspects of the protocol are decentralized, from networking and communicatino using libp2p, to storage using IPFS, to document mutations and consensus being handled with the protocol. Flexible design \u00b6 Layered approach to protocol design,many aspects of the system are modular, so it can be cofigured to your use case, for example which DID method is used, how document persistence is handled, consensus rules for documents, etc. Learn More \u00b6 Documents Network DIDs","title":"Overview"},{"location":"learn/overview/#ceramic-overview","text":"Welcome to Ceramic developer documentation. Whether you want to install Ceramic in your project, run a node or just learn the basics , this site has the tools and resources for you. First, let's explore the high-level features, capabilities, and design of Ceramic.","title":"Ceramic overview"},{"location":"learn/overview/#document-based-data-model","text":"On Ceramic, every piece of content is modeled as a mutable document . These documents can represent almost any type of information and behave similar to your favorite NoSQL database.","title":"Document-based data model"},{"location":"learn/overview/#did-based-user-model","text":"Ceramic relies on DIDs for user accounts. DIDs are used to authenticate transactions on documents and give users true control of their data.","title":"DID-based user model"},{"location":"learn/overview/#verifiable-information","text":"Authenticated, schema-enforced, consensus over state, strong security. conflict resolution.","title":"Verifiable information"},{"location":"learn/overview/#worldwidepublic-dataweb","text":"These documents can reference other documents to form a decentralized graph of linked information that lives beyond any silo. Beyond silos. Worldwide graph of information","title":"Worldwide/Public dataweb"},{"location":"learn/overview/#decentralized-network","text":"Collection of nodes all over the world that communicate over a peer-to-peer network. Is not reliant on a single server, nodes are not reliant on a supercomputer to run, designed for efficiency and scale to support all environments incl. resource constrained environments, this helps keep the network decentralized and resistant to the centralizing effects of resource demanding infrastructure. All aspects of the protocol are decentralized, from networking and communicatino using libp2p, to storage using IPFS, to document mutations and consensus being handled with the protocol.","title":"Decentralized network"},{"location":"learn/overview/#flexible-design","text":"Layered approach to protocol design,many aspects of the system are modular, so it can be cofigured to your use case, for example which DID method is used, how document persistence is handled, consensus rules for documents, etc.","title":"Flexible design"},{"location":"learn/overview/#learn-more","text":"Documents Network DIDs","title":"Learn More"},{"location":"learn/dids/methods/","text":"","title":"Methods"},{"location":"learn/dids/providers/","text":"","title":"Providers"},{"location":"learn/dids/resolvers/","text":"","title":"Resolvers"},{"location":"learn/dids/specification/","text":"","title":"Specification"},{"location":"learn/dids/wallets/","text":"","title":"Wallets"},{"location":"learn/documents/docids/","text":"","title":"Docids"},{"location":"learn/documents/document-log/","text":"","title":"Document log"},{"location":"learn/documents/document-model/","text":"Documents \u00b6 Data model \u00b6 The document log is the core underlying data structure for each Ceramic document. It contains a complete history of all updates to the document and its state can be verified by anyone by applying all previously valid transactions in the log. Document log \u00b6 The document log is the core underlying data structure for each Ceramic document. It contains a complete history of all updates to the document and its state can be verified by anyone by applying all previously valid transactions in the log. DocID \u00b6 DocIDs are uniue identifiers for documents on the Ceramic network. Specification lorem ipsum Example lorem ipsum Records \u00b6 VersionID \u00b6 Tips \u00b6 Tips are the current state of a document, represented by its most recent versionID. Metadata \u00b6 Metadata is information that lives in the header of the document. Doctypes \u00b6 Doctypes are drivers for documents on the Ceramic network. They are responsible for specifying core functionality including content requirements and consensus rules. Every document must specify which doctype it is using. Controllers \u00b6 Controllers is a required metadata property for all documents which specifies who is allowed to make updates to the document. If an entity is not included as a controller, its updates to the document will be disregarded by the protocol. The types of controllers allowed is specified by the doctype . For example tile doctypes allow DIDs as controllers, while CAIP-10 links allow blockchain addresses. Schemas \u00b6 Schemas are an optional metadata property allowed by certain doctypes, such as the tile doctype , which specifies the format and shape of the document's content. All updates to documents that specify a schema must conform to that schema; if not, those updates will be disregarded by the protocol. Schemas themselves are created as documents on Ceramic and the DocID of that schema document should be included in the schema metadata property for the document you are creating. Family \u00b6 Family is an optional metadata property for documets that is used to identify groups of related documents on the network. Tags \u00b6 Tags are optional metadata properties for documets that are used for various classifications. These are flexible and can be used to categorize information in a number of ways. Deterministic \u00b6 Deterministic is an optional metadata boolean that defaults to false. When set to true it omits a random number from being added to the genesis record which allows you to recreate the same genesis record if you create a record with the same metadata and content. Content \u00b6 The content of your document can be anything that is permitted by the doctype specified in the document's metadata. For example the tile doctype allows any JSON content, while the CAIP-10 link doctype is much more strict on allowable content.","title":"Documents"},{"location":"learn/documents/document-model/#documents","text":"","title":"Documents"},{"location":"learn/documents/document-model/#data-model","text":"The document log is the core underlying data structure for each Ceramic document. It contains a complete history of all updates to the document and its state can be verified by anyone by applying all previously valid transactions in the log.","title":"Data model"},{"location":"learn/documents/document-model/#document-log","text":"The document log is the core underlying data structure for each Ceramic document. It contains a complete history of all updates to the document and its state can be verified by anyone by applying all previously valid transactions in the log.","title":"Document log"},{"location":"learn/documents/document-model/#docid","text":"DocIDs are uniue identifiers for documents on the Ceramic network. Specification lorem ipsum Example lorem ipsum","title":"DocID"},{"location":"learn/documents/document-model/#records","text":"","title":"Records"},{"location":"learn/documents/document-model/#versionid","text":"","title":"VersionID"},{"location":"learn/documents/document-model/#tips","text":"Tips are the current state of a document, represented by its most recent versionID.","title":"Tips"},{"location":"learn/documents/document-model/#metadata","text":"Metadata is information that lives in the header of the document.","title":"Metadata"},{"location":"learn/documents/document-model/#doctypes","text":"Doctypes are drivers for documents on the Ceramic network. They are responsible for specifying core functionality including content requirements and consensus rules. Every document must specify which doctype it is using.","title":"Doctypes"},{"location":"learn/documents/document-model/#controllers","text":"Controllers is a required metadata property for all documents which specifies who is allowed to make updates to the document. If an entity is not included as a controller, its updates to the document will be disregarded by the protocol. The types of controllers allowed is specified by the doctype . For example tile doctypes allow DIDs as controllers, while CAIP-10 links allow blockchain addresses.","title":"Controllers"},{"location":"learn/documents/document-model/#schemas","text":"Schemas are an optional metadata property allowed by certain doctypes, such as the tile doctype , which specifies the format and shape of the document's content. All updates to documents that specify a schema must conform to that schema; if not, those updates will be disregarded by the protocol. Schemas themselves are created as documents on Ceramic and the DocID of that schema document should be included in the schema metadata property for the document you are creating.","title":"Schemas"},{"location":"learn/documents/document-model/#family","text":"Family is an optional metadata property for documets that is used to identify groups of related documents on the network.","title":"Family"},{"location":"learn/documents/document-model/#tags","text":"Tags are optional metadata properties for documets that are used for various classifications. These are flexible and can be used to categorize information in a number of ways.","title":"Tags"},{"location":"learn/documents/document-model/#deterministic","text":"Deterministic is an optional metadata boolean that defaults to false. When set to true it omits a random number from being added to the genesis record which allows you to recreate the same genesis record if you create a record with the same metadata and content.","title":"Deterministic"},{"location":"learn/documents/document-model/#content","text":"The content of your document can be anything that is permitted by the doctype specified in the document's metadata. For example the tile doctype allows any JSON content, while the CAIP-10 link doctype is much more strict on allowable content.","title":"Content"},{"location":"learn/documents/tips/","text":"","title":"Tips"},{"location":"learn/network/anchor-services/","text":"","title":"Anchor services"},{"location":"learn/network/clients/","text":"Network Overview \u00b6 Ceramic is a decentralized network of nodes that run the Ceramic protocol. Clients \u00b6 Clients are software that provide API access to Ceramic nodes. They allow interactions with the Ceramic network. Responsibilities \u00b6 API Interface Authenticate users Sign records Add more Client Implementations \u00b6 HTTP Client JS Client CLI Client Nodes \u00b6 Nodes are software that run the Ceramic protocol and form a peer-to-peer network with other nodes. Networking \u00b6 Network connection Nodes must specify which Ceramic network they are connecting to. This configuration allows the node to mesh with all other nodes connected to the same network. Gossip updates Nodes must specify which Ceramic network they are connecting to. This configuration allows the node to mesh with all other nodes connected to the same network. Query responses Nodes are responsible for responding to queries about any document that it has. If the node has the document in its cache it will respond directly, but if if doesn't have it, it will ask other nodes on the network for it using libp2p. Storage \u00b6 Loading documents Nodes can ask other nodes for a document and it will sync it from the network and load it in memory. This includes the entire document log (contents) and its most recent tip (state). Caching/Pinning documents Ceramic nodes use an instance of IPFS for short-term pinning/caching the documents that they care about. For each document that it cares about, a node will cache its document log and its tip. Nodes cache the Ceramic nodes come prepackaged with an internal IPFS node, but an externally run IPFS node may be used instead. (add something in here about garbage collection?) Persistence coordination Ceramic nodes may optionally specify one or more external service(s) for the long-term storage of documents. If specified, the node is responsible for forwarding document records to this service. Learn more about persistence options. Transactions \u00b6 Authentication (??) Nodes take a DID provider instance and allow that authenticated user to perform transactions. Record validation Nodes receive records (from clients (or anchor services?)) and then validate that these records conform to the rules of the document's specified doctype. Record application Nodes apply only valid records to the document's document log. Invalid or malformed records are discarded. Anchor service coordination After applying a genesis record or signed record to the document log, nodes then send these records to the HTTP endpoint of an anchor service which anchors it in a blockchain. After successfully anchoring the record, the anchor service sends back an anchor record over libp2p which is then applied to the document log by the node. Conflict resolution Should this be its own category, or should this live elsewhere? Anchor Services \u00b6 Responsibilities \u00b6 Blockchain anchoring The primary responsibility of an anchor service is to generate anchor records by committing signed records into a blockchain. All of the responsibilities below are in service of this primary responsibility. Merkle tree construction Constructs a merkle tree of all signed records that eill be simultaneously committed to a blockchain in a single hash, called a merkle root. Anchor metadata Bloom filter, helps with indexing services. Anchor status messages Sends messages to the pubsub room specified for the Ceramic network that the anchor service is servicing. This allows Ceramic nodesLearn more about anchor status messages.","title":"Network Overview"},{"location":"learn/network/clients/#network-overview","text":"Ceramic is a decentralized network of nodes that run the Ceramic protocol.","title":"Network Overview"},{"location":"learn/network/clients/#clients","text":"Clients are software that provide API access to Ceramic nodes. They allow interactions with the Ceramic network.","title":"Clients"},{"location":"learn/network/clients/#responsibilities","text":"","title":"Responsibilities"},{"location":"learn/network/clients/#client-implementations","text":"HTTP Client JS Client CLI Client","title":"Client Implementations"},{"location":"learn/network/clients/#nodes","text":"Nodes are software that run the Ceramic protocol and form a peer-to-peer network with other nodes.","title":"Nodes"},{"location":"learn/network/clients/#networking","text":"","title":"Networking"},{"location":"learn/network/clients/#storage","text":"","title":"Storage"},{"location":"learn/network/clients/#transactions","text":"","title":"Transactions"},{"location":"learn/network/clients/#anchor-services","text":"","title":"Anchor Services"},{"location":"learn/network/clients/#responsibilities_1","text":"","title":"Responsibilities"},{"location":"learn/network/nodes/","text":"","title":"Nodes"},{"location":"reference/http-api/","text":"HTTP API \u00b6 The HTTP API allows you to manually make HTTP requests that create, modify, and query documents on a remote Ceramic node. If you are building an application, you will usually interact with a node using one of the Ceramic clients , however this documentation is useful if: You have a special use case where you directly want to use HTTP requests You want to implement an HTTP client in a new language Gateway mode Not all of the API methods are available if the Ceramic node runs in gateway mode . This option disables writes, which is useful when exposing your node to the internet. Methods disabled in gateway mode will be clearly marked. Documents \u00b6 The documents endpoint is used to create new documents, load documents from their DocID or from their genesis content. Get document state \u00b6 Load the state of a document given its DocID. Request GET /api/v0/documents/:docid Here, :docid should be replaced by the string representation of the DocID of the document that is being requested. Response The response body contains the following fields: docId - the DocID of the requested document as string state - the state of the requested document as DocState Example Request $ curl http://localhost:7007/api/v0/documents/kjzl6cwe1jw147r7878h32yazawcll6bxe5v92348cxitif6cota91qp68grbhm Response { \"docId\" : \"kjzl6cwe1jw147r7878h32yazawcll6bxe5v92348cxitif6cota91qp68grbhm\" , \"state\" : { \"doctype\" : \"tile\" , \"content\" : { \"Ceramic\" : \"pottery\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [{ \"cid\" : \"bagcqceramof2xi7kh6qblirzkbc7yulcjcticlcob6uvdrx3bexgks37ilva\" , \"type\" : 0 }] , \"anchorScheduledFor\" : \"12/15/2020, 2:45:00 PM\" } } Create document \u00b6 Create a new document, or load a document from its genesis content. The genesis content may be signed (a DagJWS for the tile doctype), or unsigned in some cases. Request POST /api/v0/documents Request body fields: doctype - the name of the doctype to use (e.g. 'tile'), string genesis - the genesis content of the document (will differ per doctype) docOpts - options for the document creation, DocOpts (optional) Response The response body contains the following fields: docId - the DocID of the requested document as string state - the state of the requested document as DocState Example This example creates a tile document from an unsigned genesis commit. Note that if the content is defined for a tile genesis commit, it needs to be signed. Request $ curl http://localhost:7007/api/v0/documents -X POST -d '{ \"doctype\": \"tile\", \"genesis\": { \"header\": { \"family\": \"test\", \"controllers\": [\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"] } } }' -H \"Content-Type: application/json\" Response { \"docId\" : \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" , \"state\" : { \"doctype\" : \"tile\" , \"content\" : {} , \"metadata\" : { \"family\" : \"test\" , \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 0 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bafyreihtdxfb6cpcvomm2c2elm3re2onqaix6frq4nbg45eaqszh5mifre\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/15/2020, 3:00:00 PM\" } } Multiqueries \u00b6 The multiqueries endpoint enables querying multiple documents at once, as well as querying documents which are linked. Query multiple documents \u00b6 This endpoint allows you to query multiple DocIDs. Along with each DocID an array of paths can be passed. If any of the paths within the document structure contains a ceramic DocID url ( ceramic://<DocID> ), this linked document will also be returned as part of the response. Request POST /api/v0/multiqueries Request body fields: queries - an array of MultiQuery objects Response The response body contains a map from DocID strings to DocState objects. Example First let's create three documents to query using the ceramic cli: Request1 $ ceramic create tile --content '{ \"Document\": \"A\" }' Response1 DocID ( kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc ) { \"Document\" : \"A\" } Request2 $ ceramic create tile --content '{ \"Document\": \"B\" }' Response2 DocID ( kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0 ) { \"Document\" : \"B\" } Request3 $ ceramic create tile --content '{ \"Document\": \"C\", \"link\": \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" }' Response3 DocID ( kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl ) { \"link\" : \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" , \"Document\" : \"C\" } Now let's query them though the multiqueries endpoint: Request $ curl http://localhost:7007/api/v0/multiqueries -X POST -d '{ \"queries\": [{ \"docId\": \"kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl\", \"paths\": [\"link\"] }, { \"docId\": \"kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0\", \"paths\": [] }] }' -H \"Content-Type: application/json\" Response { \"kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl\" : { \"doctype\" : \"tile\" , \"content\" : { \"link\" : \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" , \"Document\" : \"C\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera5nx45nccxvjjyxsq3so5po77kpqzbfsydy6yflnkt6p5tnjvhbkq\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:45:00 PM\" } , \"kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" : { \"doctype\" : \"tile\" , \"content\" : { \"Document\" : \"A\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcerawq5h7otlkdwuai7vhogqhs2aeaauwbu2aqclrh4iyu5h54qqogma\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:45:00 PM\" } , \"kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0\" : { \"doctype\" : \"tile\" , \"content\" : { \"Document\" : \"B\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqceranecdjzw4xheudgkr2amjkntpktci2xv44d7v4hbft3ndpptid6ka\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:45:00 PM\" } } Commits \u00b6 The commits endpoint provides lower level access to the data structure of a Ceramic document. It is also the enpoint that is used in order to update a document, by adding a new commit. Get all document commits \u00b6 By calling get on the commits endpoint along with a DocID gives you access to all of the commits of the given document. This is useful if you want to inspect the document history, or apply all of the commits to a ceramic node that is not connected to the network. Request GET /api/v0/commits/:docid Here, :docid should be replaced by the string representation of the DocID of the document that is being requested. Response docId - the DocID of the requested document, string commits - an array of commit objects Example Request $ curl http://localhost:7007/api/v0/commits/kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv Response { \"docId\" : \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\" , \"commits\" : [ { \"cid\" : \"bagcqcera2faj5vik2giftqxftbngfndkci7x4z5vp3psrf4flcptgkz5xztq\" , \"value\" : { \"jws\" : { \"payload\" : \"AXESIAsUBpZMnue1yQ0BgXsjOFyN0cHq6AgspXnI7qGB54ux\" , \"signatures\" : [ { \"signature\" : \"16tBnfkXQU0yo-RZvfjWhm7pP-hIxJ5m-FIMHlCrRkpjbleoEcaC80Xt7qs_WZOlOCexznjow9aX4aZe51cYCQ\" , \"protected\" : \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\" } ] , \"link\" : \"bafyreialcqdjmte64624sdibqf5sgoc4rxi4d2xibawkk6oi52qydz4lwe\" } , \"linkedBlock\" : \"o2RkYXRhoWV0aXRsZXFNeSBmaXJzdCBEb2N1bWVudGZoZWFkZXKiZnNjaGVtYfZrY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SGZ1bmlxdWVwenh0b1A5blphdVgxcEE0OQ\" } } , { \"cid\" : \"bagcqcera3fkje7je4lvctkam4fvi675avtcuqgrv7dn6aoqljd5lebpl7rfq\" , \"value\" : { \"jws\" : { \"payload\" : \"AXESINm6lI30m3j5H2ausx-ulXj-L9CmFlOTZBZvJ2O734Zt\" , \"signatures\" : [ { \"signature\" : \"zsLJbBSU5xZTQkYlXwEH9xj_t_8frvSFCYs0SlVMPXOnw8zOJOsKnJDQlUOvPJxjt8Bdc_7xoBdmcRG1J1tpCw\" , \"protected\" : \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\" } ] , \"link\" : \"bafyreigzxkki35e3pd4r6zvowmp25fly7yx5bjqwkojwiftpe5r3xx4gnu\" } , \"linkedBlock\" : \"pGJpZNgqWCYAAYUBEiDRQJ7VCtGQWcLlmFpitGoSP35ntX7fKJeFWJ8zKz2+Z2RkYXRhgaNib3BjYWRkZHBhdGhlL21vcmVldmFsdWUY6mRwcmV22CpYJgABhQESINFAntUK0ZBZwuWYWmK0ahI/fme1ft8ol4VYnzMrPb5nZmhlYWRlcqFrY29udHJvbGxlcnOA\" } } ] } Apply a commit to document \u00b6 Disabled in gateway mode In order to modify a document we apply a commit to its docment log. This commit usually contains a signature over a json-patch diff describing a modification to the document contents. The commit also needs to contain pointers to the previous commit and other metadata. You can read more about this in the Ceramic Specification . Different document types may have different formats for their commits. If you want to see an example implementation for how to construct a commit you can have a look at the implementation of the TileDoctype. Request POST /api/v0/commits Request body fields: docId - the name of the doctype to use, string commit - the content of the commit to apply (will differ per doctype) docOpts - options for the document update DocOpts (optional) Response docId - the DocID of the document that was modified state - the new state of the document that was modified, DocState Example Request $ curl http://localhost:7007/api/v0/commits -X POST -d '{ \"docId\": \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\", \"commit\": { \"jws\": { \"payload\": \"AXESINm6lI30m3j5H2ausx-ulXj-L9CmFlOTZBZvJ2O734Zt\", \"signatures\": [ { \"signature\": \"zsLJbBSU5xZTQkYlXwEH9xj_t_8frvSFCYs0SlVMPXOnw8zOJOsKnJDQlUOvPJxjt8Bdc_7xoBdmcRG1J1tpCw\", \"protected\": \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\" } ], \"link\": \"bafyreigzxkki35e3pd4r6zvowmp25fly7yx5bjqwkojwiftpe5r3xx4gnu\" }, \"linkedBlock\": \"pGJpZNgqWCYAAYUBEiDRQJ7VCtGQWcLlmFpitGoSP35ntX7fKJeFWJ8zKz2+Z2RkYXRhgaNib3BjYWRkZHBhdGhlL21vcmVldmFsdWUY6mRwcmV22CpYJgABhQESINFAntUK0ZBZwuWYWmK0ahI/fme1ft8ol4VYnzMrPb5nZmhlYWRlcqFrY29udHJvbGxlcnOA\" } }' -H \"Content-Type: application/json\" Response { \"docId\" : \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\" , \"state\" : { \"doctype\" : \"tile\" , \"content\" : { \"title\" : \"My first Document\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera2faj5vik2giftqxftbngfndkci7x4z5vp3psrf4flcptgkz5xztq\" , \"type\" : 0 } , { \"cid\" : \"bagcqcera3fkje7je4lvctkam4fvi675avtcuqgrv7dn6aoqljd5lebpl7rfq\" , \"type\" : 1 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:15:00 PM\" , \"next\" : { \"content\" : { \"title\" : \"My first Document\" , \"more\" : 234 } , \"metadata\" : { \"schema\" : null, \"controllers\" : [] } } } } Pins \u00b6 The pins api endpoint can be used to manipulate the pinset. The pinset is all of the documents that a node maintains the state of. Any document opened by the node that is not pinned will eventually be garbage collected from the node. Add to pinset \u00b6 This method adds the document with the given DocID to the pinset. Disabled in gateway mode Request POST /api/v0/pins/:docid Here, :docid should be replaced by the string representation of the DocID of the document that is being requested. Response If the operation was sucessful the response will be a 200 OK. docId - the DocID of the document which was pinned, string Example Request $ curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl -X POST Response { \"docId\" : \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" } Remove from pinset \u00b6 This method removes the document with the given DocID from the pinset. Disabled in gateway mode Request DELETE /api/v0/pins/:docid Here, :docid should be replaced by the string representation of the DocID of the document that is being requested. Response If the operation was sucessful the response will be a 200 OK. docId - the DocID of the document which was unpinned, string Example Request $ curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl -X DELETE Response { \"docId\" : \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" } List documents in pinset \u00b6 Calling this method allows you to list all of the documents that are in the pinset on this node. Request GET /api/v0/pins Response pinnedDocIds - an array of DocID strings that are in the pinset Example Request $ curl http://localhost:7007/api/v0/pins Response { \"pinnedDocIds\" : [ \"k2t6wyfsu4pfwqaju0w9nmi53zo6f5bcier7vc951x4b9rydv6t8q4pvzd5w3l\" , \"k2t6wyfsu4pfxon8reod8xcyka9bujeg7acpz8hgh0jsyc7p2b334izdyzsdp7\" , \"k2t6wyfsu4pfxqseec01fnqywmn8l93p4g2chzyx3sod3hpyovurye9hskcegs\" , \"k2t6wyfsu4pfya9y0ega1vnokf0g5qaus69basy52oxg50y3l35vm9rqbb88t3\" ] } Confirm document in pinset \u00b6 This method is used to check if a particular document is in the pinset. Request GET /api/v0/pins/:docid Here, :docid should be replaced by the string representation of the DocID of the document that is being requested. Response pinnedDocIds - an array containing the specified DocID string if that document is pinned, or an empty array if that document is not pinned Example Request $ curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl Response { \"pinnedDocIds\" : [ \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" ] } Node Info \u00b6 The methods under the /node path provides more information about this particular node. Supported blockchains for anchoring \u00b6 Get all of the CAIP-2 chainIds supported by this node. Request GET /api/v0/node/chains Response The response body contains the following fields: supportedChains - and array with CAIP-2 formatted chainIds Example Request $ curl http://localhost:7007/api/v0/node/chains Response { \"supportedChains\" : [ \"eip155:3\" ] } Health check \u00b6 Check the health of the node and the machine it's running on. Run ceramic daemon -h for more details on how this can be configured. Request GET /api/v0/node/healthcheck Response Either a 200 response with the text Alive! , or a 503 with the text Insufficient resources . Example Request $ curl http://localhost:7007/api/v0/node/healthcheck Response Alive!","title":"HTTP API"},{"location":"reference/http-api/#http-api","text":"The HTTP API allows you to manually make HTTP requests that create, modify, and query documents on a remote Ceramic node. If you are building an application, you will usually interact with a node using one of the Ceramic clients , however this documentation is useful if: You have a special use case where you directly want to use HTTP requests You want to implement an HTTP client in a new language Gateway mode Not all of the API methods are available if the Ceramic node runs in gateway mode . This option disables writes, which is useful when exposing your node to the internet. Methods disabled in gateway mode will be clearly marked.","title":"HTTP API"},{"location":"reference/http-api/#documents","text":"The documents endpoint is used to create new documents, load documents from their DocID or from their genesis content.","title":"Documents"},{"location":"reference/http-api/#get-document-state","text":"Load the state of a document given its DocID. Request GET /api/v0/documents/:docid Here, :docid should be replaced by the string representation of the DocID of the document that is being requested. Response The response body contains the following fields: docId - the DocID of the requested document as string state - the state of the requested document as DocState","title":"Get document state"},{"location":"reference/http-api/#create-document","text":"Create a new document, or load a document from its genesis content. The genesis content may be signed (a DagJWS for the tile doctype), or unsigned in some cases. Request POST /api/v0/documents","title":"Create document"},{"location":"reference/http-api/#multiqueries","text":"The multiqueries endpoint enables querying multiple documents at once, as well as querying documents which are linked.","title":"Multiqueries"},{"location":"reference/http-api/#query-multiple-documents","text":"This endpoint allows you to query multiple DocIDs. Along with each DocID an array of paths can be passed. If any of the paths within the document structure contains a ceramic DocID url ( ceramic://<DocID> ), this linked document will also be returned as part of the response. Request POST /api/v0/multiqueries","title":"Query multiple documents"},{"location":"reference/http-api/#commits","text":"The commits endpoint provides lower level access to the data structure of a Ceramic document. It is also the enpoint that is used in order to update a document, by adding a new commit.","title":"Commits"},{"location":"reference/http-api/#get-all-document-commits","text":"By calling get on the commits endpoint along with a DocID gives you access to all of the commits of the given document. This is useful if you want to inspect the document history, or apply all of the commits to a ceramic node that is not connected to the network. Request GET /api/v0/commits/:docid Here, :docid should be replaced by the string representation of the DocID of the document that is being requested. Response docId - the DocID of the requested document, string commits - an array of commit objects","title":"Get all document commits"},{"location":"reference/http-api/#apply-a-commit-to-document","text":"Disabled in gateway mode In order to modify a document we apply a commit to its docment log. This commit usually contains a signature over a json-patch diff describing a modification to the document contents. The commit also needs to contain pointers to the previous commit and other metadata. You can read more about this in the Ceramic Specification . Different document types may have different formats for their commits. If you want to see an example implementation for how to construct a commit you can have a look at the implementation of the TileDoctype. Request POST /api/v0/commits","title":"Apply a commit to document"},{"location":"reference/http-api/#pins","text":"The pins api endpoint can be used to manipulate the pinset. The pinset is all of the documents that a node maintains the state of. Any document opened by the node that is not pinned will eventually be garbage collected from the node.","title":"Pins"},{"location":"reference/http-api/#add-to-pinset","text":"This method adds the document with the given DocID to the pinset. Disabled in gateway mode Request POST /api/v0/pins/:docid Here, :docid should be replaced by the string representation of the DocID of the document that is being requested. Response If the operation was sucessful the response will be a 200 OK. docId - the DocID of the document which was pinned, string","title":"Add to pinset"},{"location":"reference/http-api/#remove-from-pinset","text":"This method removes the document with the given DocID from the pinset. Disabled in gateway mode Request DELETE /api/v0/pins/:docid Here, :docid should be replaced by the string representation of the DocID of the document that is being requested. Response If the operation was sucessful the response will be a 200 OK. docId - the DocID of the document which was unpinned, string","title":"Remove from pinset"},{"location":"reference/http-api/#list-documents-in-pinset","text":"Calling this method allows you to list all of the documents that are in the pinset on this node. Request GET /api/v0/pins Response pinnedDocIds - an array of DocID strings that are in the pinset","title":"List documents in pinset"},{"location":"reference/http-api/#confirm-document-in-pinset","text":"This method is used to check if a particular document is in the pinset. Request GET /api/v0/pins/:docid Here, :docid should be replaced by the string representation of the DocID of the document that is being requested. Response pinnedDocIds - an array containing the specified DocID string if that document is pinned, or an empty array if that document is not pinned","title":"Confirm document in pinset"},{"location":"reference/http-api/#node-info","text":"The methods under the /node path provides more information about this particular node.","title":"Node Info"},{"location":"reference/http-api/#supported-blockchains-for-anchoring","text":"Get all of the CAIP-2 chainIds supported by this node. Request GET /api/v0/node/chains Response The response body contains the following fields: supportedChains - and array with CAIP-2 formatted chainIds","title":"Supported blockchains for anchoring"},{"location":"reference/http-api/#health-check","text":"Check the health of the node and the machine it's running on. Run ceramic daemon -h for more details on how this can be configured. Request GET /api/v0/node/healthcheck Response Either a 200 response with the text Alive! , or a 503 with the text Insufficient resources .","title":"Health check"},{"location":"reference/javascript/anchor-service/","text":"Anchor Service (CAS) \u00b6 The Ceramic Anchor Service (CAS) is a hosted layer 2 scalability solution for batching many Ceramic transactions into a single blockchain transaction. For details about the JavaScript CAS implementation and how to run it, refer to its repo: Ceramic Anchor Service","title":"Anchor Service"},{"location":"reference/javascript/anchor-service/#anchor-service-cas","text":"The Ceramic Anchor Service (CAS) is a hosted layer 2 scalability solution for batching many Ceramic transactions into a single blockchain transaction. For details about the JavaScript CAS implementation and how to run it, refer to its repo: Ceramic Anchor Service","title":"Anchor Service (CAS)"},{"location":"reference/javascript/clients/","text":"Clients \u00b6 The JavaScript implementation of the Ceramic Protocol consists of two main packages which can be used at runtime in your project, @ceramicnetwork/core and @ceramicnetwork/http-client . Both clients implement the same CeramicApi TypeScript interface. CeramicApi reference Core client \u00b6 The core client allows you to run the full Ceramic protocol (API and node) directly in any JavaScript environment, including directly in-browser. You might use the Core client if you want your project to be maximally decentralized. However, there are tradeoffs such as performance and data availability since this node can go on and offline as the user opens and closes browser windows. Installation | API reference HTTP client \u00b6 The HTTP clent allows you to interact with a remote Ceramic node from any JavaScript environment. The HTTP client is recommended when building most applications. Installation | API reference","title":"Clients"},{"location":"reference/javascript/clients/#clients","text":"The JavaScript implementation of the Ceramic Protocol consists of two main packages which can be used at runtime in your project, @ceramicnetwork/core and @ceramicnetwork/http-client . Both clients implement the same CeramicApi TypeScript interface. CeramicApi reference","title":"Clients"},{"location":"reference/javascript/clients/#core-client","text":"The core client allows you to run the full Ceramic protocol (API and node) directly in any JavaScript environment, including directly in-browser. You might use the Core client if you want your project to be maximally decentralized. However, there are tradeoffs such as performance and data availability since this node can go on and offline as the user opens and closes browser windows. Installation | API reference","title":"Core client"},{"location":"reference/javascript/clients/#http-client","text":"The HTTP clent allows you to interact with a remote Ceramic node from any JavaScript environment. The HTTP client is recommended when building most applications. Installation | API reference","title":"HTTP client"},{"location":"reference/javascript/did-providers/","text":"DID Providers \u00b6 A DID Provider is a library that exposes a json-rpc interface which is consumed by a Ceramic client or other DID compatible software. Usually it is constructed using a seed that the user controls. See the Authentication page for details on how to use DID providers. 3ID DID Provider \u00b6 The 3ID DID Provider allows you to create and manage a 3ID. ceramicstudio/js-3id-did-provider Key DID Provider \u00b6 A Key DID provider allows you to create and use a Key DID. Below you can find a reference implementation of the ed25519 Key DID. ceramicnetwork/key-did-provider-ed25519","title":"DID Providers"},{"location":"reference/javascript/did-providers/#did-providers","text":"A DID Provider is a library that exposes a json-rpc interface which is consumed by a Ceramic client or other DID compatible software. Usually it is constructed using a seed that the user controls. See the Authentication page for details on how to use DID providers.","title":"DID Providers"},{"location":"reference/javascript/did-providers/#3id-did-provider","text":"The 3ID DID Provider allows you to create and manage a 3ID. ceramicstudio/js-3id-did-provider","title":"3ID DID Provider"},{"location":"reference/javascript/did-providers/#key-did-provider","text":"A Key DID provider allows you to create and use a Key DID. Below you can find a reference implementation of the ed25519 Key DID. ceramicnetwork/key-did-provider-ed25519","title":"Key DID Provider"},{"location":"reference/javascript/did-resolvers/","text":"DID Resolvers \u00b6 A DID resolver is a small library that takes a DID string and returns a DID Document. Ceramic uses DID resolvers to verify transactions by comparing the signature on the transaction to the controller of the document. For the transaction to be valid, a public key corresponding to the transaction must be present in the DID Document of the DID listed as a controller. Below you can find references for the main did-resolver package as well as plugins for specific DID Methods. DID Resolver \u00b6 The main library needed to start resolving DIDs is the did-resolver package. It is maintained by the Decentralized Identity Foundation (DIF) and can be found at their github: decentralized-identity/did-resolver Plugins \u00b6 3ID DID Resolver \u00b6 The 3ID DID Method is a DID that is implemented on top of Ceramic using the tile doctype. The 3ID DID resolver uses Ceramic to resolve DIDs. ceramicnetwork/3id-did-resolver Key DID Resolver \u00b6 The Key DID Method is the most simple DID method. It simply encodes a public key in the DID string, and when resolved converts this public key into a DID Document. ceramicnetwork/key-did-resolver did:key specification","title":"DID Resolvers"},{"location":"reference/javascript/did-resolvers/#did-resolvers","text":"A DID resolver is a small library that takes a DID string and returns a DID Document. Ceramic uses DID resolvers to verify transactions by comparing the signature on the transaction to the controller of the document. For the transaction to be valid, a public key corresponding to the transaction must be present in the DID Document of the DID listed as a controller. Below you can find references for the main did-resolver package as well as plugins for specific DID Methods.","title":"DID Resolvers"},{"location":"reference/javascript/did-resolvers/#did-resolver","text":"The main library needed to start resolving DIDs is the did-resolver package. It is maintained by the Decentralized Identity Foundation (DIF) and can be found at their github: decentralized-identity/did-resolver","title":"DID Resolver"},{"location":"reference/javascript/did-resolvers/#plugins","text":"","title":"Plugins"},{"location":"reference/javascript/did-resolvers/#3id-did-resolver","text":"The 3ID DID Method is a DID that is implemented on top of Ceramic using the tile doctype. The 3ID DID resolver uses Ceramic to resolve DIDs. ceramicnetwork/3id-did-resolver","title":"3ID DID Resolver"},{"location":"reference/javascript/did-resolvers/#key-did-resolver","text":"The Key DID Method is the most simple DID method. It simply encodes a public key in the DID string, and when resolved converts this public key into a DID Document. ceramicnetwork/key-did-resolver did:key specification","title":"Key DID Resolver"},{"location":"run/deployment-tools/","text":"","title":"Deployment tools"},{"location":"run/running-a-node/","text":"","title":"Running a node"},{"location":"run/running-an-anchor-service/","text":"","title":"Running an anchor service"},{"location":"tools/networks/","text":"Networks \u00b6 Ceramic is currently available as four different networks for you to use when building and deploying your application. Public Networks \u00b6 Mainnet \u00b6 Ceramic mainnet is the main public network used for the production deployment of applications. Ceramic mainnet nodes communicate over the dedicated /ceramic/mainnet pubsub topic and are capable of anchoring documents on the Ethereum mainnet blockchain ( EIP155:1 ). Ceramic mainnet is scheduled to go live sometime around Q1 2021 . Clay \u00b6 Clay is the main public test network used for the experimental deployment of applications. Clay nodes communicate over the dedicated /ceramic/testnet-clay pubsub topic and are capable of anchoring documents on the Ethereum Rinkeby ( EIP155:? ) and Ethereum Ropsten ( EIP155:? ) testnet blockchains. Clay is available to use now. Development Networks \u00b6 Local \u00b6 Local is a private test network used for the local development of applications. Nodes connected to the same local network communicate over a randomly-generated pubsub topic /ceramic/local-$(randomNumber) and are capable of anchoring documents on a local Ethereum blockchain provided by Truffle's Ganache ( EIP155:? ). In memory \u00b6 In memory is a private...","title":"Networks"},{"location":"tools/networks/#networks","text":"Ceramic is currently available as four different networks for you to use when building and deploying your application.","title":"Networks"},{"location":"tools/networks/#public-networks","text":"","title":"Public Networks"},{"location":"tools/networks/#mainnet","text":"Ceramic mainnet is the main public network used for the production deployment of applications. Ceramic mainnet nodes communicate over the dedicated /ceramic/mainnet pubsub topic and are capable of anchoring documents on the Ethereum mainnet blockchain ( EIP155:1 ). Ceramic mainnet is scheduled to go live sometime around Q1 2021 .","title":"Mainnet"},{"location":"tools/networks/#clay","text":"Clay is the main public test network used for the experimental deployment of applications. Clay nodes communicate over the dedicated /ceramic/testnet-clay pubsub topic and are capable of anchoring documents on the Ethereum Rinkeby ( EIP155:? ) and Ethereum Ropsten ( EIP155:? ) testnet blockchains. Clay is available to use now.","title":"Clay"},{"location":"tools/networks/#development-networks","text":"","title":"Development Networks"},{"location":"tools/networks/#local","text":"Local is a private test network used for the local development of applications. Nodes connected to the same local network communicate over a randomly-generated pubsub topic /ceramic/local-$(randomNumber) and are capable of anchoring documents on a local Ethereum blockchain provided by Truffle's Ganache ( EIP155:? ).","title":"Local"},{"location":"tools/networks/#in-memory","text":"In memory is a private...","title":"In memory"},{"location":"tools/clients/cli/","text":"","title":"Cli"},{"location":"tools/clients/core/","text":"","title":"Core"},{"location":"tools/clients/http/","text":"","title":"Http"},{"location":"tools/development/clayground/","text":"Clayground \u00b6 Clayground is a docker container that simplifies deployment of the end-to-end suite of Ceramic infrastructure needed for local development and testing. Clayground runs on a local testnet . Components \u00b6 When run, Clayground will deploy: 1 2 3 4 Prerequisites \u00b6 Installation \u00b6 Usage \u00b6","title":"Clayground"},{"location":"tools/development/clayground/#clayground","text":"Clayground is a docker container that simplifies deployment of the end-to-end suite of Ceramic infrastructure needed for local development and testing. Clayground runs on a local testnet .","title":"Clayground"},{"location":"tools/development/clayground/#components","text":"When run, Clayground will deploy: 1 2 3 4","title":"Components"},{"location":"tools/development/clayground/#prerequisites","text":"","title":"Prerequisites"},{"location":"tools/development/clayground/#installation","text":"","title":"Installation"},{"location":"tools/development/clayground/#usage","text":"","title":"Usage"},{"location":"tools/dids/3id-did/","text":"3ID DID Method \u00b6 The 3ID DID Method is a DID method that uses Ceramic as a backend for managing mutable DID documents. Features \u00b6 Registration: Ceramic network DID documents: Mutable Key rotation: Supported Authenticate with a seed or an external auth method How it works \u00b6 The Providers and wallets \u00b6 need to perform key management 3ID DID Provider \u00b6 3ID Connect \u00b6 3ID Connect is a hosted DID wallet that exposes the 3ID DID provider interface to browser-based applications. 3ID Connect uses the 3ID DID provider, the 3ID Keychain, and IDX to allow users to authenticate their 3ID using external authentication providers such as blockchain wallets. To learn which blockchains are supported by 3ID Connect, see the 3id-blockchain-utils library. To learn how to add support for new blockchains, see the blog post Adding new blockchains as authentication methods to 3ID Connect .","title":"3ID DID Method"},{"location":"tools/dids/3id-did/#3id-did-method","text":"The 3ID DID Method is a DID method that uses Ceramic as a backend for managing mutable DID documents.","title":"3ID DID Method"},{"location":"tools/dids/3id-did/#features","text":"Registration: Ceramic network DID documents: Mutable Key rotation: Supported Authenticate with a seed or an external auth method","title":"Features"},{"location":"tools/dids/3id-did/#how-it-works","text":"The","title":"How it works"},{"location":"tools/dids/3id-did/#providers-and-wallets","text":"need to perform key management","title":"Providers and wallets"},{"location":"tools/dids/3id-did/#3id-did-provider","text":"","title":"3ID DID Provider"},{"location":"tools/dids/3id-did/#3id-connect","text":"3ID Connect is a hosted DID wallet that exposes the 3ID DID provider interface to browser-based applications. 3ID Connect uses the 3ID DID provider, the 3ID Keychain, and IDX to allow users to authenticate their 3ID using external authentication providers such as blockchain wallets. To learn which blockchains are supported by 3ID Connect, see the 3id-blockchain-utils library. To learn how to add support for new blockchains, see the blog post Adding new blockchains as authentication methods to 3ID Connect .","title":"3ID Connect"},{"location":"tools/dids/key-did/","text":"Ed25519 Key DID Method \u00b6 The Ed25519 Key DID method is a lightweight DID method that uses an Ed25519 key as a management key which cannot be rotated. Overview \u00b6 Unlike other DID methods which are registered and published Ed25519 DID document: immutable Authenticate with only a seed How it works \u00b6 Recommended usage \u00b6 Since the DID document is immutable and the management key cannot be rotated, it is recommended that the Ed25519 DID method be used for cases where the owner of the DID is ... Implementations \u00b6 Providers and Wallets \u00b6 Providers Ed25519 Key DID Provider Wallets There are currently no wallet implementations that support Ed25519 Key DID provider. Resolvers \u00b6 The DID resolver for the Ed25519 Key DID method is key-did-resolver-ed25519 . Ceramic support \u00b6 key-did-resolver-ed25519 is included in the JavaScript implementation of Ceramic by default and so Key DIDs are supported out of the box. The Ceramic CLI defaults to using the Ed25519 Key DID method since this is primarily a developer interface and it is assumed that developers have a good way of managing secrets. However, other DID methods supported by Ceramic can also be used by the CLI.","title":"Ed25519 Key DID Method"},{"location":"tools/dids/key-did/#ed25519-key-did-method","text":"The Ed25519 Key DID method is a lightweight DID method that uses an Ed25519 key as a management key which cannot be rotated.","title":"Ed25519 Key DID Method"},{"location":"tools/dids/key-did/#overview","text":"Unlike other DID methods which are registered and published Ed25519 DID document: immutable Authenticate with only a seed","title":"Overview"},{"location":"tools/dids/key-did/#how-it-works","text":"","title":"How it works"},{"location":"tools/dids/key-did/#recommended-usage","text":"Since the DID document is immutable and the management key cannot be rotated, it is recommended that the Ed25519 DID method be used for cases where the owner of the DID is ...","title":"Recommended usage"},{"location":"tools/dids/key-did/#implementations","text":"","title":"Implementations"},{"location":"tools/dids/key-did/#providers-and-wallets","text":"","title":"Providers and Wallets"},{"location":"tools/dids/key-did/#resolvers","text":"The DID resolver for the Ed25519 Key DID method is key-did-resolver-ed25519 .","title":"Resolvers"},{"location":"tools/dids/key-did/#ceramic-support","text":"key-did-resolver-ed25519 is included in the JavaScript implementation of Ceramic by default and so Key DIDs are supported out of the box. The Ceramic CLI defaults to using the Ed25519 Key DID method since this is primarily a developer interface and it is assumed that developers have a good way of managing secrets. However, other DID methods supported by Ceramic can also be used by the CLI.","title":"Ceramic support"},{"location":"tools/doctypes/caip-10-link/","text":"","title":"Caip 10 link"},{"location":"tools/doctypes/tile/","text":"","title":"Tile"},{"location":"tools/hosting/community-dev-node/","text":"","title":"Community dev node"},{"location":"tools/hosting/community-gateway/","text":"","title":"Community gateway"},{"location":"tools/hosting/hosting-providers/","text":"","title":"Hosting providers"},{"location":"tools/identity/idx/","text":"","title":"Idx"},{"location":"tools/identity/self-id/","text":"","title":"Self id"}]}